<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;lxthyme.github.io&quot;,&quot;root&quot;:&quot;&#x2F;blog&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;blog&#x2F;images&quot;,&quot;scheme&quot;:&quot;Muse&quot;,&quot;version&quot;:&quot;8.5.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:true,&quot;bookmark&quot;:{&quot;enable&quot;:true,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:true,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:true,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script><script src="/blog/js/config.js"></script>
<meta name="description" content="在两个有序数组中查找相同元素 在两个有序数组中 使用『折半查找』算法查找相同元素     算法 时间复杂度(平均) 时间复杂度(最好) 时间复杂度(最坏) 空间复杂度 稳定性 复杂性    冒泡排序         插入排序  $O(n)$ $O(n^2)$ $O(1)$     快速排序  $O(nlogn)$ $O(n^2)$      选择排序         希尔排序 $O(nlog_2">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS - 算法">
<meta property="og:url" content="https://lxthyme.github.io/blog/2017/12/07/iOS%20-%20%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="lxthyme">
<meta property="og:description" content="在两个有序数组中查找相同元素 在两个有序数组中 使用『折半查找』算法查找相同元素     算法 时间复杂度(平均) 时间复杂度(最好) 时间复杂度(最坏) 空间复杂度 稳定性 复杂性    冒泡排序         插入排序  $O(n)$ $O(n^2)$ $O(1)$     快速排序  $O(nlogn)$ $O(n^2)$      选择排序         希尔排序 $O(nlog_2">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lxthyme.github.io/blog/2017/12/07/iOS%20-%20%E7%AE%97%E6%B3%95/F6F976F4003CD7E753537BDC26E1540D.gif">
<meta property="og:image" content="https://lxthyme.github.io/blog/2017/12/07/iOS%20-%20%E7%AE%97%E6%B3%95/F2851E936DB05E3399829E94133609CD.gif">
<meta property="og:image" content="https://lxthyme.github.io/blog/2017/12/07/iOS%20-%20%E7%AE%97%E6%B3%95/B88537306BEDA47BE74888025DCBC864.gif">
<meta property="og:image" content="https://lxthyme.github.io/blog/2017/12/07/iOS%20-%20%E7%AE%97%E6%B3%95/3762149D65540CF3E61B5DFAACE6DC7B.gif">
<meta property="og:image" content="https://lxthyme.github.io/blog/2017/12/07/iOS%20-%20%E7%AE%97%E6%B3%95/8176304ADABD2B64233A5E5610D6D02B.png">
<meta property="og:image" content="https://lxthyme.github.io/blog/2017/12/07/iOS%20-%20%E7%AE%97%E6%B3%95/FC11D92BFE9DE07A5774E25C181615DB.png">
<meta property="og:image" content="https://lxthyme.github.io/blog/2017/12/07/iOS%20-%20%E7%AE%97%E6%B3%95/68BE847AEA4F98F70FBE19902B4C850C.gif">
<meta property="og:image" content="https://lxthyme.github.io/blog/2017/12/07/iOS%20-%20%E7%AE%97%E6%B3%95/B602E3C1FD7BA192AD8156293D57B158.jpg">
<meta property="og:image" content="https://lxthyme.github.io/blog/2017/12/07/iOS%20-%20%E7%AE%97%E6%B3%95/05D2399CD9452F35560D90244F9FB970.jpg">
<meta property="og:image" content="https://lxthyme.github.io/blog/2017/12/07/iOS%20-%20%E7%AE%97%E6%B3%95/213987A522AB40B4D76C489958BB3F40.jpg">
<meta property="og:image" content="https://lxthyme.github.io/blog/2017/12/07/iOS%20-%20%E7%AE%97%E6%B3%95/85694EBFEE9B32E0AE311C9A7C4CCB1D.jpg">
<meta property="og:image" content="https://lxthyme.github.io/blog/2017/12/07/iOS%20-%20%E7%AE%97%E6%B3%95/42BA21CDFADD5995D129B1089C165147.jpg">
<meta property="og:image" content="https://lxthyme.github.io/blog/2017/12/07/iOS%20-%20%E7%AE%97%E6%B3%95/B0FE92C55CF227CB43E1072CE7010275.jpg">
<meta property="og:image" content="https://lxthyme.github.io/blog/2017/12/07/iOS%20-%20%E7%AE%97%E6%B3%95/5E5EAB5F407EF62E554814B54BAB4524.gif">
<meta property="article:published_time" content="2017-12-07T10:35:32.000Z">
<meta property="article:modified_time" content="2018-01-26T07:16:30.000Z">
<meta property="article:author" content="lxthyme">
<meta property="article:tag" content="iOS Basic">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lxthyme.github.io/blog/2017/12/07/iOS%20-%20%E7%AE%97%E6%B3%95/F6F976F4003CD7E753537BDC26E1540D.gif">


<link rel="canonical" href="https://lxthyme.github.io/blog/2017/12/07/iOS%20-%20%E7%AE%97%E6%B3%95/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;https:&#x2F;&#x2F;lxthyme.github.io&#x2F;blog&#x2F;2017&#x2F;12&#x2F;07&#x2F;iOS%20-%20%E7%AE%97%E6%B3%95&#x2F;&quot;,&quot;path&quot;:&quot;2017&#x2F;12&#x2F;07&#x2F;iOS - 算法&#x2F;&quot;,&quot;title&quot;:&quot;iOS - 算法&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>iOS - 算法 | lxthyme</title>
  




  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">lxthyme</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.</span> <span class="nav-text">时间复杂度和空间复杂度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">2.</span> <span class="nav-text">时间复杂度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">3.</span> <span class="nav-text">空间复杂度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">4.</span> <span class="nav-text">冒泡排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">4.1.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">4.2.</span> <span class="nav-text">优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-number">4.3.</span> <span class="nav-text">算法分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E4%B8%80"><span class="nav-number">4.4.</span> <span class="nav-text">算法一</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">5.</span> <span class="nav-text">选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95-1"><span class="nav-number">5.1.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-1"><span class="nav-number">5.2.</span> <span class="nav-text">优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E4%B8%80-1"><span class="nav-number">5.3.</span> <span class="nav-text">算法一</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">6.</span> <span class="nav-text">快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95-2"><span class="nav-number">6.1.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-2"><span class="nav-number">6.2.</span> <span class="nav-text">优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E8%B6%9F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-number">6.3.</span> <span class="nav-text">一趟快速排序的算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E4%B8%80-2"><span class="nav-number">6.4.</span> <span class="nav-text">算法一</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">7.</span> <span class="nav-text">插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95-3"><span class="nav-number">7.1.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">7.2.</span> <span class="nav-text">时间复杂度与空间复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0"><span class="nav-number">7.3.</span> <span class="nav-text">算法描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-3"><span class="nav-number">7.4.</span> <span class="nav-text">优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E4%B8%80-3"><span class="nav-number">7.5.</span> <span class="nav-text">算法一</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-number">8.</span> <span class="nav-text">希尔排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E8%A7%A3"><span class="nav-number">8.1.</span> <span class="nav-text">算法分解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-1"><span class="nav-number">8.2.</span> <span class="nav-text">算法分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%92%8C%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">8.3.</span> <span class="nav-text">直接插入排序和希尔排序的比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">9.</span> <span class="nav-text">堆排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E7%9A%84%E5%AD%98%E5%82%A8"><span class="nav-number">9.1.</span> <span class="nav-text">堆的存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F-1"><span class="nav-number">9.2.</span> <span class="nav-text">堆排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E7%9A%84%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4"><span class="nav-number">9.3.</span> <span class="nav-text">堆的操作——插入删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E6%A0%B9%E5%A0%86%E5%92%8C%E5%B0%8F%E6%A0%B9%E5%A0%86"><span class="nav-number">9.4.</span> <span class="nav-text">大根堆和小根堆</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">10.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%B1%BB"><span class="nav-number">10.1.</span> <span class="nav-text">分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E9%A1%BA%E5%BA%8F"><span class="nav-number">10.2.</span> <span class="nav-text">遍历顺序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">11.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">11.1.</span> <span class="nav-text">线索二叉树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%89%E8%AF%BA%E5%A1%94"><span class="nav-number">12.</span> <span class="nav-text">汉诺塔</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="nav-number">12.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E7%AE%80%E5%8C%96"><span class="nav-number">12.2.</span> <span class="nav-text">描述简化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-2"><span class="nav-number">12.3.</span> <span class="nav-text">算法分析</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">lxthyme</p>
  <div class="site-description" itemprop="description">lxthyme's blog</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives">
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/lxthyme" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lxthyme" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/lxthyme" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;lxthyme" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/lxthyme" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;lxthyme" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/lxthyme" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lxthyme.github.io/blog/2017/12/07/iOS%20-%20%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="lxthyme">
      <meta itemprop="description" content="lxthyme's blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lxthyme">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          iOS - 算法
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-12-07 18:35:32" itemprop="dateCreated datePublished" datetime="2017-12-07T18:35:32+08:00">2017-12-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-01-26 15:16:30" itemprop="dateModified" datetime="2018-01-26T15:16:30+08:00">2018-01-26</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <ol>
<li><a href="LXAlgorithm-QA-FindCommon">在两个有序数组中查找相同元素</a></li>
<li><a href="LXAlgorithm-QA-FindCommon">在两个有序数组中 使用『折半查找』算法查找相同元素</a></li>
</ol>
<table>
<thead>
<tr>
<th align="left">算法</th>
<th align="left">时间复杂度(平均)</th>
<th align="left">时间复杂度(最好)</th>
<th align="left">时间复杂度(最坏)</th>
<th align="left">空间复杂度</th>
<th align="left">稳定性</th>
<th align="left">复杂性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">冒泡排序</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">插入排序</td>
<td align="left"></td>
<td align="left">$O(n)$</td>
<td align="left">$O(n^2)$</td>
<td align="left">$O(1)$</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">快速排序</td>
<td align="left"></td>
<td align="left">$O(nlogn)$</td>
<td align="left">$O(n^2)$</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">选择排序</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">希尔排序</td>
<td align="left">$O(nlog_2n)$</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left">不稳定</td>
<td align="left">较复杂</td>
</tr>
<tr>
<td align="left">堆排序</td>
<td align="left"></td>
<td align="left">$O(nlogn)$</td>
<td align="left"></td>
<td align="left">$O(1)$</td>
<td align="left">不稳定</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>效率: 快速 &gt; 选择 &gt; 冒泡</p>
<span id="more"></span>


<h2 id="时间复杂度和空间复杂度"><a href="#时间复杂度和空间复杂度" class="headerlink" title="时间复杂度和空间复杂度"></a>时间复杂度和空间复杂度</h2><p>常见的时间复杂度有(按数量级递增排列):</p>
<ul>
<li>常数阶: $O(n)$</li>
<li>对数阶: $O(\log^2n)$</li>
<li>线性阶: $O(n)$</li>
<li>线性对数阶: $O(n\log_2n)$</li>
<li>平方阶: $O(n^2)$</li>
<li>立方阶: $O(n^3)$</li>
<li>…</li>
<li>k次方阶: $O(n^k)$</li>
<li>指数阶: $O(2^n)$</li>
</ul>
<p>随着问题规模 n 的不断增大, 上述时间复杂度不断增大, 算法的执行效率越低.</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ol>
<li>如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。</li>
<li>当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)决定的。</li>
<li>算法的时间复杂度不仅仅依赖于问题的规模，还与输入实例的初始状态有关。</li>
</ol>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。</p>
<p>一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。程序执行时所需存储空间包括以下两部分。</p>
<ol>
<li>固定部分。这部分空间的大小与输入/输出的数据的个数多少、数值无关。主要包括指令空间（即代码空间）、数据空间（常量、简单变量）等所占的空间。这部分属于静态空间。</li>
<li>可变空间，这部分空间的主要包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。</li>
</ol>
<p>一个算法所需的存储空间用$f(n)$表示。$S(n)=O(f(n))$其中n为问题的规模，$S(n)$表示空间复杂度。</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><img data-src="F6F976F4003CD7E753537BDC26E1540D.gif" alt="1170656-40f22afb455cc9f7.gif"></p>
<p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<p>其原理为从a[0]开始，依次将其和后面的元素比较,若 a[0]&gt;a[i]，则交换它们，一直比较到a[n]。同理对a[1],a[2],…a[n-1]处 理，即完成排序;</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>冒泡法原理简单，但其缺点是交换次数多，效率低</p>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
<p>原始待排序数组| 6 | 2 | 4 | 1 | 5 | 9 |</p>
<p>第一趟排序(外循环)<br>第一次两两比较6 &gt; 2交换(内循环)<br>交换前状态| 6 | 2 | 4 | 1 | 5 | 9 |<br>交换后状态| 2 | 6 | 4 | 1 | 5 | 9 |</p>
<p>第二次两两比较,6 &gt; 4交换<br>交换前状态| 2 | 6 | 4 | 1 | 5 | 9 |<br>交换后状态| 2 | 4 | 6 | 1 | 5 | 9 |</p>
<p>第三次两两比较,6 &gt; 1交换<br>交换前状态| 2 | 4 | 6 | 1 | 5 | 9 |<br>交换后状态| 2 | 4 | 1 | 6 | 5 | 9 |</p>
<p>第四次两两比较,6 &gt; 5交换<br>交换前状态| 2 | 4 | 1 | 6 | 5 | 9 |<br>交换后状态| 2 | 4 | 1 | 5 | 6 | 9 |</p>
<p>第五次两两比较,6 &lt; 9不交换<br>交换前状态| 2 | 4 | 1 | 5 | 6 | 9 |<br>交换后状态| 2 | 4 | 1 | 5 | 6 | 9 |</p>
<p>第二趟排序(外循环)<br>第一次两两比较2 &lt; 4不交换<br>交换前状态| 2 | 4 | 1 | 5 | 6 | 9 |<br>交换后状态| 2 | 4 | 1 | 5 | 6 | 9 |</p>
<p>第二次两两比较,4 &gt; 1交换<br>交换前状态| 2 | 4 | 1 | 5 | 6 | 9 |<br>交换后状态| 2 | 1 | 4 | 5 | 6 | 9 |</p>
<p>第三次两两比较,4 &lt; 5不交换<br>交换前状态| 2 | 1 | 4 | 5 | 6 | 9 |<br>交换后状态| 2 | 1 | 4 | 5 | 6 | 9 |</p>
<p>第四次两两比较,5 &lt; 6不交换<br>交换前状态| 2 | 1 | 4 | 5 | 6 | 9 |<br>交换后状态| 2 | 1 | 4 | 5 | 6 | 9 |</p>
<p>第三趟排序(外循环)<br>第一次两两比较2 &gt; 1交换<br>交换后状态| 2 | 1 | 4 | 5 | 6 | 9 |<br>交换后状态| 1 | 2 | 4 | 5 | 6 | 9 |</p>
<p>第二次两两比较,2 &lt; 4不交换<br>交换后状态| 1 | 2 | 4 | 5 | 6 | 9 |<br>交换后状态| 1 | 2 | 4 | 5 | 6 | 9 |</p>
<p>第三次两两比较,4 &lt; 5不交换<br>交换后状态| 1 | 2 | 4 | 5 | 6 | 9 |<br>交换后状态| 1 | 2 | 4 | 5 | 6 | 9 |</p>
<p>第四趟排序(外循环)无交换<br>第五趟排序(外循环)无交换</p>
<p>排序完毕,输出最终结果1 2 4 5 6 9</p>
<h3 id="算法一"><a href="#算法一" class="headerlink" title="算法一"></a>算法一</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j, temp;</span><br><span class="line">  <span class="comment">/*注意循环的上下限*/</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(a[i] &gt; a[j]) &#123;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>选择法循环过程与冒泡法相似，它还定义了记号k=i,然后依次把a[k]同后面元素比较，若a[k]&gt;a[j],则使k=j.最后看看k=i是否还成立，不成立则交 换a[k],a[i],这样就比 冒泡法省下许多无用的交换，提高了效率。</p>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>选择法比冒泡法效率更高</p>
<h3 id="算法一-1"><a href="#算法一-1" class="headerlink" title="算法一"></a>算法一</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">choise</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j, temp;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    k = i;<span class="comment">/*给记号赋值*/</span></span><br><span class="line">    <span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="comment">/*使k总是指向最小元素*/</span></span><br><span class="line">      <span class="keyword">if</span>(a[k] &gt; a[j]) &#123; k = j; &#125;</span><br><span class="line">      <span class="keyword">if</span>(i != k) &#123;<span class="comment">/*当k!=i时才交换，否则a[i]即为最小*/</span></span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><img data-src="F2851E936DB05E3399829E94133609CD.gif" alt="1170656-aa523ec3ba9a2909.gif"></p>
<p>快速排序（Quicksort）是对冒泡排序的一种改进。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<p>在平均状况下，排序 n 个项目要$Ο(n logn)$次比较。在最坏状况下则需要$Ο(n^2)$次比较，但这种状况并不常见。</p>
<p>快速排序使用分治法(Divide and conquer)策略来把一个串行(list)分为两个子串行(sub-lists)。</p>
<h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p>快速法定义了三个参数，(数组首地址*a,要排序数组起始元素下标i,要排序数组结束元素下标j). 它首先先选一个数组元素(一般为a[(i+j)/2],即中间元素)作为参照，把 比它小的元素放到它的左边，比它大的放在右边。然后运用递归，在将它左，右两个子数组排序，最后完成整个数组的排序。</p>
<p>从数列中挑出一个元素，称为 “基准”(pivot)，重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面(相同的数可以到任一边)。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区(partition)操作。递归地(recursive)把小于基准值元素的子数列和大于基准值元素的子数列排序。递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代(iteration)中，它至少会把一个元素摆到它最后的位置去。</p>
<h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p>效率: 快速排序 &gt; 选择排序 &gt; 冒泡排序</p>
<h3 id="一趟快速排序的算法"><a href="#一趟快速排序的算法" class="headerlink" title="一趟快速排序的算法"></a>一趟快速排序的算法</h3><ol>
<li>设置两个变量i、j，排序开始的时候：i=0，j=N-1；</li>
<li>以第一个数组元素作为关键数据，赋值给key，即key=A[0]；</li>
<li>从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；</li>
<li>从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；</li>
<li>重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。</li>
</ol>
<h3 id="算法一-2"><a href="#算法一-2" class="headerlink" title="算法一"></a>算法一</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low, high, temp, key;</span><br><span class="line">  low = i;</span><br><span class="line">  high = j;</span><br><span class="line">  key = a[(i + <span class="number">1</span>) / <span class="number">2</span>];<span class="comment">/*选取的参照*/</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">/* 从左到右找比k大的元素*/</span></span><br><span class="line">    <span class="keyword">while</span>(a[low] &lt; key &amp;&amp; low &lt; j) &#123; low++; &#125;</span><br><span class="line">    <span class="comment">/* 从右到左找比k小的元素*/</span></span><br><span class="line">    <span class="keyword">while</span>(a[high] &gt; key &amp;&amp; high &gt; i) &#123; high--; &#125;</span><br><span class="line">    <span class="keyword">if</span>(low &lt;= high) &#123;<span class="comment">/*若找到且满足条件，则交换*/</span></span><br><span class="line">      temp = a[low];</span><br><span class="line">      a[low] = a[high];</span><br><span class="line">      a[high] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">while</span>(low &lt;= high);</span><br><span class="line">  <span class="comment">/*运用递归*/</span></span><br><span class="line">  <span class="keyword">if</span>(low &lt; j) &#123; quick(a, low, j); &#125;</span><br><span class="line">  <span class="keyword">if</span>(high &gt; i) &#123; quick(a, i, high); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h3><p>插入排序就是每一步都将一个待排数据按其大小插入到已经排序的数据中的适当位置，直到全部插入完毕。 插入排序方法分直接插入排序和折半插入排序两种。</p>
<p><img data-src="B88537306BEDA47BE74888025DCBC864.gif" alt="1170656-8f8fe207ea0d0609.gif"></p>
<h3 id="时间复杂度与空间复杂度"><a href="#时间复杂度与空间复杂度" class="headerlink" title="时间复杂度与空间复杂度"></a>时间复杂度与空间复杂度</h3><p>时间复杂度：O（n^2)<br>空间复杂度：O（1）</p>
<p>最少比较次数：（已排序的数组）n-1次<br>最多比较次数：（降序的数组）n(n-1)/2次</p>
<p>数组在已排序或者是“近似排序”时，插入排序效率的最好情况运行时间为O(n)；插入排序最坏情况运行时间和平均情况运行时间都为O（n^2) 。</p>
<p>插入排序不适合对大量数据排序，适合对接近排序的数据排序。插入排序是稳定排序。通常，插入排序呈现出二次排序算法中的最佳性能。对于具有较少元素（如n&lt;=15）的列表来说，二次算法十分有效。在列表已被排序时，插入排序是线性算法O(n)。在列表“近似排序”时，插入排序仍然是线性算法。在列表的许多元素已位于正确的位置上时，就会出现“近似排序”的条件。</p>
<h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>假定n是数组的长度，首先假设第一个元素被放置在正确的位置上，这样仅需从1到n-1范围内对剩余元素进行排序。对于每次遍历，从0到i-1范围内的元素已经被排好序，每次遍历的任务是：通过扫描前面已排序的子列表，将位置i处的元素定位到从0到i的子列表之内的正确的位置上。</p>
<p>将arr[i]复制为一个名为target的临时元素。向下扫描列表，比较这个目标值target与arr[i-1]、arr[i-2]的大小，依次类推。这个比较过程在小于或等于目标值的第一个元素(arr[j])处停止，或者在列表开始处停止（j=0）。在arr[i]小于前面任何已排序元素时，后一个条件（j=0）为真，因此，这个元素会占用新排序子列表的第一个位置。在扫描期间，大于目标值target的每个元素都会向右滑动一个位置（arr[j]=arr[j-1]）。一旦确定了正确位置j，目标值target（即原始的arr[i]）就会被复制到这个位置。与选择排序不同的是，插入排序将数据向右滑动，并且不会执行交换。</p>
<h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3><h3 id="算法一-3"><a href="#算法一-3" class="headerlink" title="算法一"></a>算法一</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j, temp;<span class="comment">/*temp为要插入的元素*/</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    temp = a[i];</span><br><span class="line">    j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; a[j]) &#123;</span><br><span class="line">      <span class="comment">/*从a[i-1]开始找比a[i]小的数，同时把数组元素向后移*/</span></span><br><span class="line">      a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*插入*/</span></span><br><span class="line">    a[j + <span class="number">1</span>] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p><img data-src="3762149D65540CF3E61B5DFAACE6DC7B.gif" alt="1170656-1afe3a613ae119f8.gif"></p>
<p>希尔排序，也称<strong>递减增量排序算法</strong>，是插入排序的一种高速而稳定的改进版本。因Donald Shell于1959年提出而得名。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ol>
<li>插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率；</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。</li>
</ol>
<p>该方法的<strong>基本思想</strong>是：先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。</p>
<p>因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率上比前两种方法有较大提高。</p>
<p>希尔排序总结来说就是把记录按步长 gap 分组，对每组记录采用直接插入排序方法进行排序。随着步长逐渐减小，所分成的组包含的记录越来越多，当步长的值减小到 1 时，整个数据合成为一组，构成一组有序记录，则完成排序。</p>
<h3 id="算法分解"><a href="#算法分解" class="headerlink" title="算法分解"></a>算法分解</h3><p><img data-src="8176304ADABD2B64233A5E5610D6D02B.png" alt="1170656-829f7298e8515980.png"></p>
<ul>
<li>初始时，有一个大小为 10 的无序序列。在第一趟排序中，我们不妨设 gap1 = N / 2 = 5，即相隔距离为 5 的元素组成一组，可以分为 5 组。接下来，按照直接插入排序的方法对每个组进行排序。</li>
<li>在第二趟排序中，我们把上次的 gap 缩小一半，即 gap2 = gap1 / 2 = 2 (取整数)。这样每相隔距离为 2 的元素组成一组，可以分为 2 组。按照直接插入排序的方法对每个组进行排序。</li>
<li>在第三趟排序中，再次把 gap 缩小一半，即gap3 = gap2 / 2 = 1。 这样相隔距离为 1 的元素组成一组，即只有一组。按照直接插入排序的方法对每个组进行排序。此时，排序已经结束。</li>
</ul>
<p><strong>需要注意一下的是，图中有两个相等数值的元素 5 和 5 。我们可以清楚的看到，在排序过程中，两个元素位置交换了。所以，希尔排序是不稳定的算法。</strong></p>
<h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><p><img data-src="FC11D92BFE9DE07A5774E25C181615DB.png" alt="1170656-58a3a1df06f4d6a7.png"></p>
<ul>
<li>步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。</li>
</ul>
<p>Donald Shell 最初建议步长选择为N/2并且对步长取半直到步长达到1。虽然这样取可以比O(N2)类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。可能希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。比如，如果一个数列以步长5进行了排序然后再以步长3进行排序，那么该数列不仅是以步长3有序，而且是以步长5有序。如果不是这样，那么算法在迭代过程中会打乱以前的顺序，那就不会以如此短的时间完成排序了。</p>
<h3 id="直接插入排序和希尔排序的比较"><a href="#直接插入排序和希尔排序的比较" class="headerlink" title="直接插入排序和希尔排序的比较"></a>直接插入排序和希尔排序的比较</h3><p>直接插入排序是稳定的；而希尔排序是不稳定的。直接插入排序更适合于原始记录基本有序的集合。希尔排序的比较次数和移动次数都要比直接插入排序少，当N越大时，效果越明显。 在希尔排序中，增量序列gap的取法必须满足：最后一个步长必须是 1 。 直接插入排序也适用于链式存储结构；希尔排序不适用于链式结构。</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><img data-src="68BE847AEA4F98F70FBE19902B4C850C.gif" alt="1170656-fc6040d719b38ba0.gif"></p>
<p>堆排序是时间复杂度为$O(nlogn)$的排序方法。是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。</p>
<p>堆分为<strong>大根堆</strong>和<strong>小根堆</strong>，是<strong>完全二叉树</strong>。</p>
<p><strong>大根堆</strong>的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。</p>
<p>由于建初始堆所需的比较次数较多，所以堆排序不适宜于记录数较少的文件。堆排序是就地排序，辅助空间为O(1）.它是不稳定的排序方法。（排序的稳定性是指如果在排序的序列中，存在前后相同的两个元素的话，排序前 和排序后他们的相对位置不发生变化）</p>
<h3 id="堆的存储"><a href="#堆的存储" class="headerlink" title="堆的存储"></a>堆的存储</h3><p>一般都用数组来表示堆，i结点的父结点下标就为$(i – 1) / 2$。它的左右子结点下标分别为$2i + 1$和$2i + 2$。如第0个结点左右子结点下标分别为1和2。</p>
<p>每次插入都是将新数据放在数组最后。可以发现从这个新数据的父结点到根结点必然为一个有序的数列，现在的任务是将这个新数据插入到这个有序数据中——这就类似于直接插入排序中将一个数据并入到有序区间中。</p>
<p>堆的删除，按定义，堆中每次都只能删除第0个数据。为了便于重建堆，实际的操作是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。调整时先在左右儿子结点中找最小的，如果父结点比这个最小的子结点还小说明不需要调整了，反之将父结点和它交换后再考虑后面的结点。相当于从根结点将一个数据的“下沉”过程。</p>
<p><img data-src="B602E3C1FD7BA192AD8156293D57B158.jpg" alt="1170656-93d8ca6bb0141c27.jpeg"></p>
<h3 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆建好之后堆中第0个数据是堆中最小的数据。取出这个数据再执行下堆的删除操作。这样堆中第0个数据又是堆中最小的数据，重复上述步骤直至堆中只有一个数据时就直接取出这个数据。由于堆也是用数组模拟的，故堆化数组后，第一次将A[0]与A[n - 1]交换，再对A[0…n-2]重新恢复堆。第二次将A[0]与A[n – 2]交换，再对A[0…n - 3]重新恢复堆，重复这样的操作直到A[0]与A[1]交换。由于每次都是将最小的数据并入到后面的有序区间，故操作完成后整个数组就有序了。</p>
<h3 id="堆的操作——插入删除"><a href="#堆的操作——插入删除" class="headerlink" title="堆的操作——插入删除"></a>堆的操作——插入删除</h3><p><img data-src="05D2399CD9452F35560D90244F9FB970.jpg" alt="1170656-faef5d3396f116f8.jpeg"></p>
<h3 id="大根堆和小根堆"><a href="#大根堆和小根堆" class="headerlink" title="大根堆和小根堆"></a>大根堆和小根堆</h3><p>根结点（亦称为堆顶）的关键字是堆里所有结点关键字中最小者的堆称为<strong>小根堆</strong>，又称最小堆。</p>
<p>根结点（亦称为堆顶）的关键字是堆里所有结点关键字中最大者，称为大根堆，又称<strong>最大堆</strong>。堆中任一子树亦是堆。</p>
<p>堆实际上是二叉堆（Binary Heap），类似地可定义k叉堆。</p>
<p>大根堆排序算法的基本操作：</p>
<ol>
<li><p><strong>建堆</strong>，建堆是不断调整堆的过程，从len/2处开始调整，一直到第一个节点，此处len是堆中元素的个数。建堆的过程是线性的过程，从len/2到0处一直调用调整堆的过程，相当于o(h1)+o(h2)…+o(hlen/2) 其中h表示节点的深度，len/2表示节点的个数，这是一个求和的过程，结果是线性的O(n)。</p>
</li>
<li><p>调整堆：调整堆在构建堆的过程中会用到，而且在堆排序过程中也会用到。利用的思想是比较节点i和它的孩子节点left(i),right(i)，选出三者最大(或者最小)者，如果最大（小）值不是节点i而是它的一个孩子节点，那边交互节点i和该节点，然后再调用调整堆过程，这是一个递归的过程。调整堆的过程时间复杂度与堆的深度有关系，是lgn的操作，因为是沿着深度方向进行调整的。</p>
</li>
<li><p>堆排序：堆排序是利用上面的两个过程来进行的。首先是根据元素构建堆。然后将堆的根节点取出(一般是与最后一个节点进行交换)，将前面len-1个节点继续进行堆调整的过程，然后再将根节点取出，这样一直到所有节点都取出。堆排序过程的时间复杂度是O(nlgn)。因为建堆的时间复杂度是O(n)（调用一次）；调整堆的时间复杂度是lgn，调用了n-1次，所以堆排序的时间复杂度是O(nlgn)。</p>
</li>
</ol>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现<strong>二叉查找树</strong>和<strong>二叉堆</strong>(详见<a href="#%E5%A0%86%E6%8E%92%E5%BA%8F">算法 - 堆排序</a>)。二叉树不是树的一种特殊情形，尽管其与树有许多相似之处，但树和二 叉树有两个主要差别：树中结点的最大度数没有限制，而二叉树结点的最大度数为2； 树的结点无左、右之分，而二叉树的结点有左、右之分。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol>
<li><p><strong>完全二叉树</strong>: 若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。</p>
</li>
<li><p><strong>满二叉树</strong>: 除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。</p>
</li>
<li><p><strong>平衡二叉树</strong>: 平衡二叉树又被称为<strong>AVL树</strong>（区别于AVL算法），它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
</li>
</ol>
<p><img data-src="213987A522AB40B4D76C489958BB3F40.jpg" alt="IMAGE"></p>
<p>二叉树的存储结构有<strong>顺序</strong>和<strong>链式</strong>两种方式。前者虽然使用简单，但是存在浪费空间的问题，举个例子，下图的二叉树，用顺序的方式存储(0表示空，没有子树)是1 2 3 4 5 6 7 0 0 0 0 8 0 0 0。</p>
<p><img data-src="85694EBFEE9B32E0AE311C9A7C4CCB1D.jpg" alt="IMAGE"></p>
<p>链式结构可以参考<a href="#%E9%93%BE%E8%A1%A8">算法 - 链表</a>。</p>
<h3 id="遍历顺序"><a href="#遍历顺序" class="headerlink" title="遍历顺序"></a>遍历顺序</h3><p><strong>先序遍历</strong>: 先访问根结点，再左子树，再右子树。<br><strong>中序遍历</strong>: 先访问左子树,再根结点，再右子树。<br><strong>后序遍历</strong>: 先访问左子树,再右子树，再根结点。</p>
<p>递归固然是清晰明了，但是存在效率低的问题.</p>
<p>非递归的方案用栈结构来存结点信息，通过出栈访问来遍历二叉树。它思想是这样的，当栈顶中的指针非空时，遍历左子树，也就是左子树根的指针进栈。当栈顶指针为空时，应退至上一层，如果是从左子树返回的，访问当前层，也就是栈顶中的根指针结点。如果是从右子树返回，说明当前层遍历完毕，继续退栈。</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。</p>
<p><img data-src="42BA21CDFADD5995D129B1089C165147.jpg" alt="IMAGE"></p>
<p>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。</p>
<p>链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的存取往往要在不同的排列顺序中转换。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。</p>
<p>链表有很多种不同的类型：<strong>单向链表</strong>，<strong>双向链表</strong>以及<strong>循环链表</strong>。</p>
<p>总结来说，相比较普通的线性结构，链表结构的优势是单个节点创建非常方便，普通的线性内存通常在创建的时候就需要设定数据的大小；节点的删除非常方便，不需要像线性结构那样移动剩下的数据；节点的访问方便，可以通过循环或者递归的方法访问到任意数据，但是平均的访问效率低于线性表。</p>
<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p><img data-src="B0FE92C55CF227CB43E1072CE7010275.jpg" alt="IMAGE"></p>
<p>线索二叉树(保留遍历时结点在任一序列的前驱和后继的信息)：若结点有左子树，则其lchild域指示其左孩子，否则令lchild域指示其前驱；若结点有右子树，则其rchild域指示其右孩子，否则令rchild指示其后继。还需在结点结构中增加两个标志域LTag和RTag。LTag=0时，lchild域指示结点的左孩子，LTag=1时，lchild域指示结点的前驱；RTag=0时，rchild域指示结点的右孩子，RTag=1时，rchild域指示结点的后继。</p>
<p>以这种结点结构构成的二叉线索链表，链表作为二叉树的存储结构，叫做其中指向结点前驱和后继的指针叫做<strong>线索</strong>，加上线索的二叉树称为<strong>线索二叉树</strong>。对二叉树以某种次序遍历使其变为线索二叉树的过程叫做<strong>线索化</strong>。若对二叉树进行中序遍历，则所得的线索二叉树称为<strong>中序线索二叉树</strong>，线索链表称为为<strong>中序线索链表</strong>。线索二叉树是一种物理结构。</p>
<p>在中序线索树找结点后继的规律是：若其右标志为1，则右链为线索，指示其后继，否则遍历其右子树时访问的第一个结点（右子树最左下的结点）为其后继；找结点前驱的规律是：若其左标志为1，则左链为线索，指示其前驱，否则遍历左子树时最后访问的一个结点（左子树中最右下的结点）为其前驱。</p>
<p>在后序线索树中找到结点的后继分三种情况：<br>若结点是二叉树的根，则其后继为空；<br>若结点是其双亲的右孩子，或是其双亲的左孩子且其双亲没有右子树，则其后继即为双亲结点；<br>若结点是其双亲的左孩子，且其双亲有右子树，则其后继为双亲右子树上按后序遍历列出的第一个结点。</p>
<h2 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h2><p><img data-src="5E5EAB5F407EF62E554814B54BAB4524.gif" alt="1170656-de98c09516e52274.gif"></p>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>有一个梵塔，塔内有三个座A、B、C，A座上有诺干个盘子，盘子大小不等，大的在下，小的在上（如图）。</p>
<p>把这些个盘子从A座移到C座，中间可以借用B座但每次只能允许移动一个盘子，并且在移动过程中，3个座上的盘</p>
<p>子始终保持大盘在下，小盘在上。</p>
<h3 id="描述简化"><a href="#描述简化" class="headerlink" title="描述简化"></a>描述简化</h3><p>把A柱上的n个盘子移动到C柱，其中可以借用B柱。</p>
<h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><p>A上有n个盘子。</p>
<p>如果n=1，则将圆盘从A直接移动到C。</p>
<p>如果n=2，则：<br>1）将A上的n-1（等于1）个圆盘移到B上；<br>2）再将A上的一个圆盘移到C上；<br>3）最后将B上的n-1（等于1）个圆盘移到C上。</p>
<p>如果n=3，则：<br>将A上的n-1（等于2，令其为n’）个圆盘移到B（借助于C），步骤如下：<br>1）将A上的n’-1（等于1）个圆盘移到C上。<br>2）将A上的一个圆盘移到B。<br>3）将C上的n’-1（等于1）个圆盘移到B。</p>
<p>B将A上的一个圆盘移到C。</p>
<p>C将B上的n-1（等于2，令其为n’）个圆盘移到C（借助A），步骤如下：<br>1）将B上的n’-1（等于1）个圆盘移到A。<br>2）将B上的一个盘子移到C。<br>3）将A上的n’-1（等于1）个圆盘移到C。到此，完成了三个圆盘的移动过程。</p>
<p>从上面分析可以看出，当n大于等于2时， 移动的过程可分解为三个步骤：第一步 把A上的n-1个圆盘移到B上；第二步 把A上的一个圆盘移到C上；第三步 把B上的n-1个圆盘移到C上；其中第一步和第三步是类同的。 当n=3时，第一步和第三步又分解为类同的三步，即把n’-1个圆盘从一个针移到另一个针上，这里的n’=n-1。</p>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/blog/2017/12/25/URL Scheme/" rel="bookmark">URL Scheme</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/blog/2018/01/08/iOS - Run Loop/" rel="bookmark">iOS - Run Loop</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/blog/2017/12/27/iOS - 动画篇/" rel="bookmark">iOS - 动画篇</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/blog/2018/01/08/iOS - 推送/" rel="bookmark">iOS - 推送</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/blog/2017/12/26/iOS - 演变『简略』/" rel="bookmark">iOS - 演变『简略』</a></div>
    </li>
  </ul>


    <footer class="post-footer">
          <div class="reward-container">
  <div></div>
  <button onclick="document.querySelector('.post-reward').classList.toggle('active');">
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/blog/images/wechatpay.png" alt="lxthyme 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/blog/images/alipay.png" alt="lxthyme 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
        <a target="_blank" class="social-link" href="https://twitter.com/lxthyme">
          <span class="icon">
            <i class="fab fa-twitter"></i>
          </span>

          <span class="label">Twitter</span>
        </a>
      </div>

      <div class="social-item">
        <a target="_blank" class="social-link" href="/blog/atom.xml">
          <span class="icon">
            <i class="fa fa-rss"></i>
          </span>

          <span class="label">RSS</span>
        </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/blog/tags/ios-basic/" rel="tag"># iOS Basic</a>
          </div>

        
  <div class="post-widgets">
    <div class="wp_rating">
      <div id="wpac-rating"></div>
    </div>
  </div>

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/blog/2017/05/26/iOS%E4%B9%8BUI%E7%9B%B8%E5%85%B3/" rel="prev" title="iOS之UI相关">
                  <i class="fa fa-chevron-left"></i> iOS之UI相关
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/blog/2017/12/25/URL%20Scheme/" rel="next" title="URL Scheme">
                  URL Scheme <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lxthyme</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/blog/js/comments.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/motion.js"></script><script src="/blog/js/schemes/muse.js"></script><script src="/blog/js/next-boot.js"></script><script src="/blog/js/bookmark.js"></script>

  
  <script src="https://embed.widgetpack.com/widget.js" async></script>
  <script class="next-config" data-name="rating" type="application/json">{&quot;enable&quot;:true,&quot;id&quot;:null,&quot;color&quot;:&quot;#fc6423&quot;}</script>
  <script src="/blog/js/third-party/rating.js"></script>






  





</body>
</html>
